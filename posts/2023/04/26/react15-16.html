<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React15到React16发生什么了 | 维维梓的博客 ｜ WeiS Blog</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/logo.png">
    <meta name="description" content="个人博客">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.f8d19f53.css" as="style"><link rel="preload" href="/assets/js/app.7b77c2c0.js" as="script"><link rel="preload" href="/assets/js/6.c637be34.js" as="script"><link rel="preload" href="/assets/js/13.2515b1db.js" as="script"><link rel="prefetch" href="/assets/js/10.0b5928ed.js"><link rel="prefetch" href="/assets/js/11.5fb46a50.js"><link rel="prefetch" href="/assets/js/12.fb57822d.js"><link rel="prefetch" href="/assets/js/14.91cadf63.js"><link rel="prefetch" href="/assets/js/15.c23ba4c7.js"><link rel="prefetch" href="/assets/js/16.51dd775e.js"><link rel="prefetch" href="/assets/js/2.35a0a702.js"><link rel="prefetch" href="/assets/js/3.fc3cf85f.js"><link rel="prefetch" href="/assets/js/4.76b9324e.js"><link rel="prefetch" href="/assets/js/5.0175d747.js"><link rel="prefetch" href="/assets/js/7.f81a89ad.js"><link rel="prefetch" href="/assets/js/8.693ba13f.js"><link rel="prefetch" href="/assets/js/9.5834a689.js">
    <link rel="stylesheet" href="/assets/css/0.styles.f8d19f53.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="global-layout" data-v-7f2e4136><header class="header-container" data-v-93921ff8 data-v-7f2e4136><nav class="navbar" style="position:absolute;opacity:1;transition:all 0.5s ease-in-out;" data-v-93921ff8><a href="/" class="navbar-link router-link-active">
    WeiS Blog
  </a> <ul class="navbar-links"><li><a href="/" class="router-link-active">
        HOME
      </a></li><li><a href="/about/">
        ABOUT
      </a></li><li><a href="/tags/">
        TAGS
      </a></li></ul> <div id="nav-icon"><span></span><span></span><span></span></div></nav> <div class="header-title" data-v-93921ff8 data-v-93921ff8><h1 data-v-93921ff8>React15到React16发生什么了</h1> <p data-v-93921ff8>实现快速响应</p></div></header> <div class="container" data-v-b3fda33c data-v-7f2e4136><main class="main" style="width:60%;" data-v-b3fda33c><div class="post" data-v-b3fda33c data-v-b3fda33c><article class="main-div"><div class="post-content content content__default"><p>React15到React16就是为了更好的实现React的理念——<strong>快速响应</strong>。必须要做到：可中断！
</p> <h1 id="react-15-到-react-16"><a href="#react-15-到-react-16" class="header-anchor">#</a> React 15 到 React 16</h1> <p>之前已经了解到了React的理念就是<strong>快速响应</strong>，而React16的由来就是因为React15并不能很好的满足<strong>快速响应</strong>的理念，所以我们先来看看React15的缺点。</p> <h3 id="老的react15架构"><a href="#老的react15架构" class="header-anchor">#</a> 老的React15架构</h3> <p>React15架构可以分为两层：</p> <ul><li>Reconciler（协调器）—— 负责找出变化的组件</li> <li>Renderer（渲染器）—— 负责将变化的组件渲染到页面上</li></ul> <h4 id="_1-reconciler-协调器"><a href="#_1-reconciler-协调器" class="header-anchor">#</a> 1.Reconciler(协调器)</h4> <p>每当有更新发生时，<strong>Reconciler</strong>会做如下工作：</p> <ul><li>调用函数组件、或class组件的<code>render</code>方法，将返回的JSX转化为虚拟DOM</li> <li>将虚拟DOM和上次更新时的虚拟DOM对比</li> <li>通过对比找出本次更新中变化的虚拟DOM</li> <li>通知<strong>Renderer</strong>将变化的虚拟DOM渲染到页面上</li></ul> <h4 id="_2-renderer-渲染器"><a href="#_2-renderer-渲染器" class="header-anchor">#</a> 2.Renderer（渲染器）</h4> <p>不同平台有不同的<strong>Renderer</strong>。我们前端最熟悉的是负责在浏览器环境渲染的<strong>Renderer</strong> —— <a href="https://www.npmjs.com/package/react-dom" target="_blank" rel="noopener noreferrer">ReactDOM<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>而<strong>Renderer</strong>的作用就是在每次更新发生时，<strong>Renderer</strong>接到<strong>Reconciler</strong>通知，将变化的组件渲染在当前的环境。</p> <h4 id="_3-react15架构的缺点"><a href="#_3-react15架构的缺点" class="header-anchor">#</a> 3.React15架构的缺点</h4> <p>React15的架构是通过<strong>递归更新</strong>来实现的，挂载的组件调用<strong>mountComponent</strong>，更新的组件调用<strong>updateComponent</strong>，这两个方法都会递归更新子组件，那这样的递归更新是无法中断的，并且<strong>Reconciler</strong>和<strong>Renderer</strong>是交替工作的，违背了刚刚我们所说的<code>React</code>解决<strong>快速响应</strong>的方法——用<strong>可中断</strong>的异步更新代替同步的更新，具体可以看<a href="https://qinziweis.github.io/posts/2023/04/04/react.html" target="_blank" rel="noopener noreferrer">React理念<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>这一篇，于是乎<code>React</code>重写了整个架构</p> <h3 id="新的react16架构"><a href="#新的react16架构" class="header-anchor">#</a> 新的React16架构</h3> <p>React16架构可以分为三层：</p> <ul><li>Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入<strong>Reconciler</strong></li> <li>Reconciler（协调器）—— 负责找出变化的组件</li> <li>Renderer（渲染器）—— 负责将变化的组件渲染到页面上</li></ul> <p>可以看到，相较于React15，React16中新增了<strong>Scheduler（调度器）</strong>，让我们来了解下他。</p> <h4 id="_1-scheduler-调度器"><a href="#_1-scheduler-调度器" class="header-anchor">#</a> 1. Scheduler（调度器）</h4> <p>既然我们以浏览器是否有剩余时间作为任务中断的标准，那么我们需要一种机制，当浏览器有剩余时间时通知我们。</p> <p><strong>Scheduler</strong>会接收需要更新的任务，在浏览器有剩余时间时触发回调，并且提供了多种调度优先级，可以设置给任务。高优先级的任务可以随时打断正在进行中的低优先级任务。</p> <h4 id="_2-reconciler-协调器"><a href="#_2-reconciler-协调器" class="header-anchor">#</a> 2.Reconciler（协调器）</h4> <p>我们知道，在React15中<strong>Reconciler</strong>是递归处理虚拟DOM的。而React16中，更新工作从递归变成了可以中断的循环过程。每次循环都会调用<code>shouldYield</code>判断当前是否有剩余时间。</p> <p>那么如果中断更新时，DOM渲染不完全呢?这会导致页面出现异常。</p> <p>所以React16中的<strong>Reconciler</strong>和<strong>Renderer</strong>不再是交替工作了，而是<strong>Scheduler</strong>江任务交给<strong>Reconciler</strong>后，<strong>Reconciler</strong>会为这些变化的虚拟DOM打上某个代表操作类型（增删改）的标记，将所有的组件都完成<strong>Reconciler</strong>的工作后，将统一交给<strong>Renderer</strong>去渲染</p> <h4 id="_3-renderer-渲染器"><a href="#_3-renderer-渲染器" class="header-anchor">#</a> 3.Renderer（渲染器）</h4> <p><strong>Renderer</strong>根据<strong>Reconciler</strong>为虚拟DOM打的标记，同步执行对应的DOM操作。</p> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <p>总的来说，React15-&gt;React16发生的变化就是如下：</p> <ul><li>新增<strong>Scheduler</strong>，负责监听需要完成的任务，并且有了优先级，高优先级任务打断低优先级任务</li> <li>不再是交替着工作，而是<strong>Reconciler</strong>根据<strong>Scheduler</strong>的任务进行判断，将所有需要更改的虚拟DOM全找出来之后，再统一交给<strong>Renderer</strong></li> <li>不再是递归更新，导致无法中断。<strong>Scheduler</strong>和<strong>Reconciler</strong>的工作随时都可以中断，并且因为<strong>Renderer</strong>并没有收到要更新的消息，页面也不会有异常变化。</li></ul></div></article> <!----></div></main> <aside class="aside" data-v-b3fda33c data-v-b3fda33c><div class="info-card main-div" data-v-1311ce9e data-v-b3fda33c><div class="info-card-header" data-v-1311ce9e><img src="/avatar.jpg" alt="维维梓" class="info-avatar" data-v-1311ce9e></div> <div class="info-card-body" data-v-1311ce9e><section class="info-name" data-v-1311ce9e>
      维维梓
    </section> <section class="info-desc" data-v-1311ce9e>一个爱说唱的程序员</section> <section class="info-contact" data-v-1311ce9e><section data-v-1311ce9e><span data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:1em;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-location" data-v-1311ce9e data-v-1311ce9e></use></svg><span class="info-text" data-v-1311ce9e data-v-1311ce9e>
          Shanghai, China
        </span></span></section> <!----> <section data-v-1311ce9e><span data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:1em;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-email" data-v-1311ce9e data-v-1311ce9e></use></svg><span class="info-text" data-v-1311ce9e data-v-1311ce9e>
          2201553139@qq.com
        </span></span></section></section></div> <div class="info-card-footer" data-v-1311ce9e><p class="footer-sns-link" data-v-1311ce9e><a target="_blank" href="https://github.com/QinZiWeiS" class="sns-link" data-v-1311ce9e><span class="sns-icon" data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:35px;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-github" data-v-1311ce9e data-v-1311ce9e></use></svg></span></a></p></div></div> <div class="post-toc main-div aside-toc" style="position:relative;top:0;width:0px;" data-v-b3fda33c><h4>- CATALOG</h4> <div class="post-nav-toc"><ul><li><a href="/posts/2023/04/26/react15-16.html#老的react15架构">老的React15架构</a><ul><li><a href="/posts/2023/04/26/react15-16.html#新的react16架构">新的React16架构</a></li><li><a href="/posts/2023/04/26/react15-16.html#总结">总结</a></li></ul></li></ul></div></div></aside></div> <footer class="footer" data-v-7f2e4136><p class="footer-sns-link"><a target="_blank" href="https://github.com/QinZiWeiS" class="sns-link"><span class="sns-icon"><svg class="icon" style="font-size:40px;"><use xlink:href="#icon-github"></use></svg></span></a></p> <div class="copyright"><span id="custom">Copyright &copy; WeiS Blog 2023</span> <!----></div></footer></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.7b77c2c0.js" defer></script><script src="/assets/js/6.c637be34.js" defer></script><script src="/assets/js/13.2515b1db.js" defer></script>
  </body>
</html>
