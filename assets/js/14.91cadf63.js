(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{457:function(e,r,_){"use strict";_.r(r);var v=_(1),t=Object(v.a)({},(function(){var e=this,r=e._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("p",[e._v("了解了解React Fiber的起源和架构，为后续的源码阅读做准备！\n")]),e._v(" "),r("h1",{attrs:{id:"react-fiber"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react-fiber"}},[e._v("#")]),e._v(" React Fiber")]),e._v(" "),r("p",[e._v("在React15中，有虚拟DOM这样一个概念，负责视图，而"),r("strong",[e._v("Reconciler")]),e._v("在对虚拟DOM树做diff算法的时候不允许外界打断的，这是一个递归的过程，而fiber的提出就很好的解决了这个问题。")]),e._v(" "),r("p",[e._v("在React16中，虚拟DOM有个正式的称呼——"),r("code",[e._v("Fiber")]),e._v("，不再是曾经用于递归的虚拟DOM数据结构了。")]),e._v(" "),r("h3",{attrs:{id:"fiber的目标"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#fiber的目标"}},[e._v("#")]),e._v(" Fiber的目标")]),e._v(" "),r("p",[e._v("为了满足React16的"),r("strong",[e._v("Scheduler")]),e._v("调度，核心概念就是可以随心所欲的控制我们的代码，具体来说则是：")]),e._v(" "),r("ul",[r("li",[e._v("可以暂停工作，稍后再回来")]),e._v(" "),r("li",[e._v("为不同类型工作分配优先级")]),e._v(" "),r("li",[e._v("重用之前完成的工作")]),e._v(" "),r("li",[e._v("如果不再需要，则中止工作")])]),e._v(" "),r("h3",{attrs:{id:"fiber是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#fiber是什么"}},[e._v("#")]),e._v(" Fiber是什么")]),e._v(" "),r("p",[e._v("Fiber的含义有几种：")]),e._v(" "),r("ol",[r("li",[e._v("可以理解为一种架构，也就是常说的"),r("code",[e._v("FIber树")]),e._v("。实现了“双缓存技术”；")]),e._v(" "),r("li",[e._v("本质上可以理解为一种数据结构，是个最小的工作单元，每一个Fiber节点都对应一个 React element，保存了对应的DOM节点信息，大量的Fiber节点组成了一个链表，这是虚拟DOM树的另外一种表示。")])]),e._v(" "),r("h3",{attrs:{id:"fiber作为架构的工作原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#fiber作为架构的工作原理"}},[e._v("#")]),e._v(" Fiber作为架构的工作原理")]),e._v(" "),r("p",[e._v("就像前面提到的那样，"),r("code",[e._v("React")]),e._v("使用“双缓存技术”来完成"),r("code",[e._v("Fiber树")]),e._v("的构建和替换，对应着的就是DOM树的创建与更新。")]),e._v(" "),r("blockquote",[r("p",[r("strong",[e._v("在内存中构建并直接替换")]),e._v("的技术叫做"),r("a",{attrs:{href:"https://baike.baidu.com/item/%E5%8F%8C%E7%BC%93%E5%86%B2",target:"_blank",rel:"noopener noreferrer"}},[e._v("双缓存"),r("OutboundLink")],1)])]),e._v(" "),r("p",[e._v("在React中最多会同时存在两棵"),r("code",[e._v("Fiber树")]),e._v("：")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("当前屏幕上显示内容对应的"),r("code",[e._v("Fiber树")]),e._v("称为"),r("code",[e._v("current Fiber树")])])]),e._v(" "),r("li",[r("p",[e._v("正在内存中构建的"),r("code",[e._v("Fiber树")]),e._v("称为"),r("code",[e._v("workInProgress Fiber树")]),e._v("。")])])]),e._v(" "),r("p",[e._v("两棵树对应着两种不同的节点：")]),e._v(" "),r("ul",[r("li",[r("code",[e._v("current Fiber树")]),e._v("中的"),r("code",[e._v("Fiber节点")]),e._v("被称为`current fiber``")]),e._v(" "),r("li",[e._v("``workInProgress Fiber树"),r("code",[e._v("中的")]),e._v("Fiber节点"),r("code",[e._v("被称为")]),e._v("workInProgress fiber`")]),e._v(" "),r("li",[e._v("他们通过"),r("code",[e._v("alternate")]),e._v("属性连接。")])]),e._v(" "),r("p",[e._v("替换原理：")]),e._v(" "),r("p",[r("code",[e._v("React")]),e._v("应用的根节点通过使"),r("code",[e._v("current")]),e._v("指针在不同"),r("code",[e._v("Fiber树")]),e._v("的"),r("code",[e._v("rootFiber")]),e._v("间切换来完成"),r("code",[e._v("current Fiber")]),e._v("树指向的切换。")]),e._v(" "),r("p",[e._v("即当"),r("code",[e._v("workInProgress Fiber树")]),e._v("构建完成交给"),r("code",[e._v("Renderer")]),e._v("渲染在页面上后，应用根节点的"),r("code",[e._v("current")]),e._v("指针指向"),r("code",[e._v("workInProgress Fiber树")]),e._v("，此时"),r("code",[e._v("workInProgress Fiber树")]),e._v("就变为"),r("code",[e._v("current Fiber树")]),e._v("。")]),e._v(" "),r("p",[e._v("每次状态更新都会产生新的"),r("code",[e._v("workInProgress Fiber树")]),e._v("，通过"),r("code",[e._v("current")]),e._v("与"),r("code",[e._v("workInProgress")]),e._v("的替换，完成"),r("code",[e._v("DOM")]),e._v("更新。")]),e._v(" "),r("h3",{attrs:{id:"总结"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),r("p",[e._v("了解了Fiber的起源与架构，Fiber节点，链表结构，存储DOM信息，可以构成Fiber树，而Fiber树又通过双缓存技术进行替换和更新。")])])}),[],!1,null,null,null);r.default=t.exports}}]);